# Tabela Sistemas Operacionais:

| Categoria Principal | Subcategoria | Conceito/Definição | Características | Tipos/Classificações | Exemplos/Mecanismos | Funções/Objetivos | Problemas/Desafios | Soluções/Algoritmos | Comparação/Notas | Fonte(s) |
|---|---|---|---|---|---|---|---|---|---|---|
| **Sistemas Operacionais (S.O.) - Geral** | Introdução e Definição | Parte essencial de qualquer sistema computacional. Um conjunto de rotinas executado pelo processador, semelhante aos programas de usuários. | Serve como interface entre usuários e recursos disponíveis, tornando a comunicação transparente e eficiente, com menores chances de erros. Gerencia o computador de forma eficiente e produtiva. Controla o funcionamento de um computador, gerenciando a utilização e compartilhamento de recursos. | | | Gerenciar o computador de forma eficiente e produtiva. Facilitar o acesso a recursos do sistema. Organizar o compartilhamento de recursos para garantir sua proteção. Controlar o funcionamento do computador gerenciando processadores, memórias e dispositivos de entrada e saída. | A proposta é escolher um S.O. que atenda às necessidades de uma empresa de consultoria acadêmica de pequeno porte. | | A unidade de ensino 01 aborda a introdução e evolução dos S.O., além de tipos e exemplos como Windows e Unix. | |
| | Camadas do S.O. | A estrutura em que os sistemas operacionais trabalham para realizar suas tarefas. | Os usuários interagem com as aplicações, que interagem com o sistema operacional, que por sua vez se comunica com os dispositivos de hardware. Máquinas processam informações em linguagem binária (0 e 1). | | **USUÁRIO -> APLICATIVOS -> SISTEMA OPERACIONAL -> HARDWARE** | | | O interpretador de comandos é o programa do S.O. responsável por codificar comandos e operações para que a máquina possa processar e exibir o resultado. | | |
| | Kernel (Núcleo do S.O.) | O núcleo do sistema operacional. Conjunto de rotinas. | É composto por um processador, memória e sistema de arquivos. | | | Responsável pela gerência dos dispositivos de entrada e saída. Realiza o controle e tratamento de interrupções e exceções. Cria e elimina processos e threads. Sincroniza a comunicação entre eles. Escalona e controla processos. Gerencia memória, sistemas de arquivos, dispositivos de E/S. Permite suporte a redes locais e distribuídas. Realiza a contabilização das ações do sistema, sua auditoria e segurança. | | | É acionado por uma "chamada de sistema" feita pelo interpretador de comandos. O S.O. é basicamente composto por esse conjunto de rotinas. | |
| | System Call (Chamada de Sistema) | Um mecanismo de controle para as rotinas que o sistema executará. | Pode ser explícito (instrução no próprio programa) ou implícito (inserção de comando da linguagem de programação). | Explícito, Implícito | | É responsável por verificar os parâmetros da solicitação e enviar a resposta com o estado do processo (concluído ou erro). | | | | |
| | Linguagens de Comando / Shell Scripts | Ferramentas importantes para a criação de arquivos de comandos. | Viabilizam a automatização de algumas tarefas de gerência do sistema operacional. | Batch, Shell Scripts | | Automatizar tarefas de gerência do sistema. | | O shell é responsável por interpretar esses comandos. | | |
| | Evolução do S.O. | Contexto histórico dos Sistemas Operacionais. | A evolução está diretamente relacionada com a evolução do hardware e das aplicações. Termos iniciais como "programa" ou "job" foram substituídos por "processo" e "subprocesso", e posteriormente "thread". | | O primeiro S.O. conhecido foi o "monitor", desenvolvido em 1953 por uma equipe da General Motors para o computador IBM701. | | | | | |
| **Tipos de Sistemas Operacionais** | Classificação Geral | Categorização dos S.O. com base em suas capacidades e o número de tarefas/processadores que podem gerenciar. | | Monoprogramáveis/Monotarefa. Multiprogramáveis/Multitarefa. Sistemas com múltiplos processadores. | | | | | | |
| | Monotarefa | Sistemas operacionais que utilizam todos os recursos da máquina para processar uma única tarefa por vez. | O processador ficava ocioso. Não utilizava todos os recursos de memória se o programa não ocupasse todo o espaço. Periféricos dedicados a um único usuário, sem preocupação com compartilhamento. | | **Ex.: MS-DOS**. | | Ineficiência no uso de recursos devido à ociosidade do processador e memória. | | Não é viável manter apenas o MS-DOS atualmente, devido à necessidade de trabalhar com vários aplicativos e programas simultaneamente. | |
| | Multitarefa/Multiprogramável | Sistemas operacionais que permitem o processamento de mais de um aplicativo ou programa simultaneamente. | Baseados no compartilhamento de recursos. Gerenciam o processamento, memória e compartilhamento de recursos. | Monousuário (utilizado por apenas um usuário, ex: editar texto, usar internet ao mesmo tempo). Multiusuário (requer compartilhamento de recursos). | | Gerenciar processamento, memória e compartilhamento de recursos para múltiplas tarefas. | | | Representa o segundo marco na evolução dos S.O.. | |
| | Sistemas com Múltiplos Processadores | Sistemas que utilizam duas ou mais Unidades Centrais de Processamento (UCPs) que trabalham em conjunto. | Uma máquina pode executar vários programas simultaneamente. O processamento pode ser dividido entre os processadores. | Fortemente acoplados (vários processadores compartilhando uma única memória física, gerenciados por um único S.O. para E/S). Fracamente acoplados (dois ou mais sistemas interconectados em rede, cada um independente com seu próprio S.O. e gerenciamento de recursos). | **Ex.:** Utilizados para processamento de imagens e desenvolvimento aeroespacial. **Fortemente acoplados Ex.:** Unix, Windows. | | | | Vantagens: **escalabilidade** (ampliar potencial de processamento), **disponibilidade** (manter processo em execução mesmo com falhas, embora mais lentamente), **balanceamento de carga** (distribuição de processamento para melhorar desempenho). | |
| | S.O. Embarcados | Sistemas operacionais projetados para dispositivos com recursos limitados. | Usados em computadores de mão. Possuem características de S.O. de tempo real. Têm limitações de memória e consumo de energia. | | **Ex.:** Celulares, aparelhos de TV, fornos micro-ondas. tvOS (Apple), WebOS (LG), Tizen (Samsung). | | | | | |
| | S.O. Mobile | Sistemas operacionais encontrados em dispositivos móveis. | Mais simples. Permitem a comunicação de dados sem fio por bluetooth e Wi-Fi. Permitem a utilização de rádio, câmera, gravador de voz, entre outros. | | **Ex.:** Celulares, tablets, MP3 players. Android, Windows Phone, iOS. | | | | | |
| | S.O. na Nuvem | Sistemas operacionais que utilizam conceitos baseados na computação na nuvem. | Todos os serviços oferecidos (banco de dados, redes) são feitos pela internet. Todos os dados do usuário e aplicativos ficam na nuvem (armazenamento de dados via web). O acesso é via internet. | | **Ex.:** Google Chrome OS (lançado em 2009). | | | | | |
| | S.O. de Cartões Inteligentes | Os menores sistemas operacionais, presentes em dispositivos como cartões de crédito. | Dispositivos do tamanho de cartões de crédito que contêm um chip de CPU. Têm restrições severas de memória e energia. | | | | Limitados a pagamentos eletrônicos e saques. | | | |
| **Unidades Funcionais do S.O.** | Processador | Componente principal que gerencia o sistema computacional. | | | | Gerenciar o sistema computacional. | | | Ciclo de busca e instruções: 1. Busca endereço CI na memória principal e armazena em RI. 2. Atualiza CI com endereço da próxima instrução. 3. Decodifica instrução do RI. 4. Busca operando em memória. 5. Busca instrução decodificada e reinicia o processo. | |
| | Unidade de Controle (UC) | Componente do processador. | | | | Gerencia as atividades dos componentes do computador, como gravação de dados e localização de instruções. | | | | |
| | Unidade Lógica e Aritmética (ULA) | Componente do processador. | | | | Realiza operações lógicas e aritméticas. | | | | |
| | Registradores | Pequenas unidades de armazenamento dentro do processador. | | | | Armazenam dados temporariamente. | | | Incluem o Controlador de Instruções (CI), Apontador da Pilha (AP/SP), Registrador de Instruções (RI), e Registrador de Status (PSW). | |
| | Controlador de Instruções (CI) | Um registrador. | | | | Contém o endereço da próxima instrução para o processador executar. | | | | |
| | Apontador da Pilha (AP) / Stack Pointer (SP) | Um registrador. | | | | Refere-se às instruções que estão no topo da pilha de execução e contém seu endereço na memória. | | | | |
| | Registrador de Instruções (RI) | Um registrador. | | | | Armazena a instrução que será decodificada pelo processador. | | | | |
| | Registrador de Status / Program Status Word (PSW) | Um registrador. | | | | Armazena informações sobre os processos em execução. | | | | |
| **Características de S.O. Multiprogramáveis** | Interrupção | Evento assíncrono que ocorre em função de um evento externo ao programa em uso. | Não depende de um processo em execução. Ocorre de forma assíncrona, não vinculada à execução do programa. | | Exemplo: um dispositivo de entrada/saída encerra uma tarefa, o processador interrompe a execução para executar instruções de encerramento. | Possibilita a implementação de concorrência entre processos. Sincroniza tarefas e sua execução com operações de usuários e controle de dispositivos. | | A unidade de controle é acionada para verificar o evento e iniciar a rotina de tratamento de interrupção. As instruções de tratamento são armazenadas em um registrador para restaurar o processo interrompido. Necessidade de um controlador de pedidos de interrupção. | Há dois tipos de tratamento: vetor de interrupção (guarda endereço do conjunto de instruções) e registrador de status (armazena o tipo de evento). | |
| | Tratamento de Interrupção | Processo pelo qual o S.O. lida com um evento de interrupção. | | | 1. Processador recebe sinalização do evento. 2. Processador encerra instrução atual e interrompe processamento do programa. 3. Registradores tipo PC são acionados para guardar instruções. 4. Processador verifica rotina associada e busca informação no registrador. 5. Tratamento é salvo e entra na pilha de controle do programa. 6. Rotina de tratamento é executada. 7. Informações salvas nos registradores de uso geral são restauradas para que o processador continue a execução do programa interrompido. | | | | Fatores fundamentais na escolha de um S.O., pois não prejudicam o processamento de informações executadas paralelamente. | |
| | Exceção | Evento ocorrido em função do processamento do programa, sendo síncrono e diretamente ligado ao programa. | Ocorre em função do processamento do programa. Síncrona. | | Exemplo: overflow (divisão por zero) não previsto no código-fonte. | | Gera um erro lógico que ocorrerá todas as vezes em que o programa for executado. | A solução é prever esse tipo de erro e incluir o tratamento das exceções no próprio programa. | | |
| | Operações de Entrada e Saída (E/S) | Operações que envolvem a comunicação com dispositivos de entrada e saída. | Inicialmente controladas por um conjunto de instruções de E/S. Atualmente, há pouca intervenção da UCP, pois novas arquiteturas têm um processador de entrada e saída. | E/S controlada por programa, E/S controlada por interrupção. | | Otimizar o tempo e uso de recursos pelo computador. | Diferença de processamento, leitura e gravação de novas instruções de E/S. | O controlador (interface) reconhece comandos e solicitações e se comunica com hardware/software, dispensando comunicação direta do processador. | | |
| | Buffering | Técnica para transmissão de dados de dispositivos de E/S para a memória principal. | Usa registradores para o transporte. O dado é transferido primeiramente ao buffer, permitindo acesso imediato à informação. | | | Libera os dispositivos de E/S para receber novas instruções. Reduz o problema de diferença de processamento, leitura e gravação de instruções de E/S. Permite vários registros armazenados e não lidos. | | | O buffer pode variar em tamanho de acordo com o tipo de informação. | |
| | Spooling (Simultaneous Peripheral Operation On-Line) | Técnica introduzida em 1950 para aumentar a possibilidade de trabalho com processos concorrentes. | Armazena um conjunto de instruções ou Jobs em fita magnética para serem processados. A técnica era realizada sequencialmente para cada job. | | | Diminuir o tempo de processamento e busca por cada instrução. | | | A saída desse processamento era o armazenamento da informação em outra fita magnética ou área do disco rígido. Foi a base para o processamento batch. | |
| **Comparação de S.O.** | Windows vs. Linux | Análise comparativa das características e diferenças entre os sistemas operacionais Windows e Linux. | | | | | | | **Licença:** Windows (paga, licença Microsoft por computador) vs. Linux (GNU Public License - GPL, gratuita, pode usar em quantas máquinas quiser). **Acesso ao Código-Fonte:** Windows (restrito aos desenvolvedores) vs. Linux (aberto, usuários podem acessar e modificar). **Linha de Comando:** Windows (possui, mas menos efetiva que Linux, configurações via GUI) vs. Linux (ponto forte, administração efetiva). **Flexibilidade/Rigidez:** Windows (regras definidas pela Microsoft) vs. Linux (usuário adepta o S.O. ao seu desejo, ambiente gráfico). **Preço:** Windows (pago por licença) vs. Linux (gratuito). **Suporte:** Windows (suporte pago Microsoft, fóruns) vs. Linux (fóruns, sites de ajuda, suporte de grandes empresas). **Popularidade:** Windows (padrão de uso devido a acordos com fabricantes) vs. Linux (popularidade cresce, mais pessoas conhecem vantagens). **Hardware:** Ambos exigem configuração mínima para rodar "confortavelmente". | |
| **Processos e Threads** | Processo | Um programa ou tarefa em execução. Uma instância de um programa em execução, incluindo valores do contador de programa atual, registradores e variáveis. | Possui um programa, entrada, saída e um estado. Pode ser iniciado pelo usuário (ex: editor de texto) ou por outros processos (ex: página da internet solicitando ajuda). | CPU-bound (ocupa mais UCP, mais tempo em execução e pronto, em aplicações com muitos cálculos). I/O-bound (passa a maior parte do tempo em estado de espera, em aplicações com muitas tarefas de leitura/gravação/processamento). | **Ex.:** Ler um livro online, baixar um arquivo, navegar na internet. | O S.O. é o responsável por administrá-los através do gerenciador de processos. | | A CPU funciona como uma linha de produção, alternando programas rapidamente para dar a ilusão de paralelismo (pseudoparalelismo). A alternância da CPU entre processos é conhecida como multiprogramação. | A diferença entre processo e programa é importante (programa é o código estático, processo é a execução do programa). | |
| | Estados do Processo | Fases pelas quais um processo passa, controladas pelo S.O.. | Nos sistemas multiprogramáveis, os processos não recebem de forma dedicada todos os recursos da máquina. | **Execução (Running):** Processado pela UCP. **Pronto (Ready):** Aguardando para ser processado. **Espera/Bloqueado (Wait/Blocked):** Aguarda um recurso para continuar ou o tratamento de um evento. | | | | Processos em espera são organizados em listas encadeadas e mudam para o estado "pronto" ao receberem os recursos necessários. | Considera o estado "bloqueado" com a mesma função do estado de "espera". | |
| | PCB (Process Control Block) | Bloco de controle de processos. | Composto por sinais (bits) que administram a comunicação entre eventos e sua sincronização. Pode ficar em modo de espera até que o processo seja escalonado. | | | Administrar a comunicação entre eventos e sua sincronização. | | | Se o processo for eliminado, o bit correspondente é acionado e ele é excluído apenas ao entrar em execução, ou seja, os sinais respondem diretamente aos processos. | |
| | Criação e Finalização de Processos | Eventos que marcam o início e o fim da vida útil de um processo. | | **Criação:** Início do sistema, processo em execução, requisição do usuário, tarefa em lote. **Fim:** Saída normal (voluntária), saída por erro, erro fatal, solicitação de outro processo. | | | | | | |
| | Comunicação S.O. e Usuário | As três formas de comunicação entre o S.O. e o usuário. | Cada forma tem seu acesso e armazenamento de dados reservado em memória. Se um arquivo for compartilhado, a veracidade e precisão das informações devem ser garantidas. | Procedimentos próprios do sistema, interação com aplicativos, linguagens de comando. | | Estabelecer o tipo de comunicação e o modo (usuário ou kernel). | | O S.O. recebe o status da situação (sequência de bits de identificação - ID no registrador) para acionar o modo correto. | **Modo Usuário:** apenas instruções não privilegiadas (não oferecem risco ao sistema) podem ser executadas, com menor quantidade de instruções. **Modo Kernel:** o S.O. tem acesso irrestrito às instruções do processador (instruções privilegiadas que podem interferir no funcionamento do kernel). | |
| | Sincronização de Leitura e Gravação | Mecanismos para gerenciar a troca de informações entre processos concorrentes que compartilham um buffer. | Há o compartilhamento do buffer, que armazena temporariamente as informações para acesso rápido e processamento. | | | Garantir a integridade e confiabilidade das ações do sistema. Gravação ocorre apenas se o buffer estiver vazio. Leitura ocorre apenas se houver dados para leitura. | | **Mecanismos de Sincronização:** **FORK** (cria subprocessos/processos filho, associa e acompanha sua execução). **JOIN** (sincroniza processos criados pelo FORK, permitindo a execução de um processo apenas após o encerramento de outro). | | |
| **Tratamento de Erros e Deadlock** | Mecanismos de Tratamento de Erros | Algoritmos propostos para reduzir a probabilidade de ocorrência de erros e garantir a integridade e confiabilidade do sistema. | Visam garantir a integridade e confiabilidade das ações do sistema. | Exclusão Mútua, Sincronização Condicional, Semáforos, Monitores, Troca de Mensagens. | | Reduzir a ocorrência de erros e garantir a execução correta. | | | | |
| | Exclusão Mútua (Mutual Exclusion) | Mecanismo que impede que dois ou mais processos sejam executados simultaneamente compartilhando o mesmo recurso. | | | | | | | | |
| | Sincronização Condicional | Mecanismo que implementa a sincronização da execução dos processos associada a uma verificação condicional de acesso à região crítica. | | | | | | | | |
| | Semáforos | Mecanismo implementado por Dijkstra em 1965 para exclusão mútua com condição de acesso à região crítica. | É uma variável inteira. Realiza duas operações indivisíveis executadas no processador: DOWN (P de proeberen/teste, decrementa uma unidade) e UP (V de verhogen/incremento, incrementa uma unidade). | Binários (mutexes, valores 0 ou 1, onde 1=recurso livre, 0=recurso em uso). Contadores (qualquer valor inteiro positivo, além de 0). | | Garantir exclusão mútua e sincronização condicional. | | | Semáforo com valor 0 indica que nenhum sinal de acordar foi salvo; >0 indica um ou mais sinais pendentes. É um dos mecanismos mais utilizados em projetos de S.O. e aplicações concorrentes, com procedimentos disponíveis em muitas linguagens de programação. | |
| | Monitores | Mecanismos propostos por Brinch Hansen em 1972. | São implementados pelo compilador. Considerados estruturados. | | | | | | | |
| | Troca de Mensagens | Mecanismo de comunicação entre processos que não necessita de variáveis compartilhadas. | Estabelece um canal de comunicação. | | Envio (SEND) e recebimento (RECEIVE) de mensagens para sincronização. | Sincronizar a execução dos processos. | | | | |
| | Deadlock | Situação em que um processo aguarda por tempo indeterminado a alocação de um recurso ou um evento que não ocorrerá. | Ocorre em função da alocação dinâmica de recursos que trabalham com concorrência. | | | | A aplicação (software de gestão integrada) trabalha de forma concorrente. | O algoritmo de Dijkstra pode auxiliar na alocação de recursos para comunicação e sincronização de processos, prevenindo deadlocks. | | |
| | Algoritmo de Dijkstra | Algoritmo que implanta o uso do conceito de semáforo para a sincronização de processos. | | | **Ex.: Problema dos Filósofos** (5 filósofos, 5 garfos, comem e pensam, precisam de 2 garfos para comer). Regras para evitar deadlock: 1. Apenas 4 filósofos podem sentar-se. 2. Um filósofo só pode usar um garfo se ele estiver disponível. 3. Um filósofo só pode usar primeiro o garfo da direita e depois o da esquerda. | Auxiliar na alocação de recursos para a comunicação e sincronização de processos. Prevenir a ocorrência de deadlocks. | | | Aplicação sugerida para uma clínica médica: alocar recursos para solicitações de clientes (pacientes) sobre consultórios/clínicas próximos e agendamento. | |
| **Escalonamento de Processos** | Introdução ao Escalonamento | Processo pelo qual o S.O. escolhe, de forma eficiente, qual processo, dentre os aptos, ocupará a CPU. | Nos computadores, vários processos competem pela CPU. | | | Otimizar a utilização do processador. Definir o processo que ocupará a CPU. Prezar pelos critérios e objetivos de escalonamento. | | O escalonador de processos é o responsável, aplicando algoritmos ou políticas de escalonamento. | | |
| | Critérios de Escalonamento | Fatores utilizados para analisar a eficiência e determinar o tipo de escalonamento a ser aplicado. | São determinados de acordo com as características do sistema operacional. | **Eficiência e Utilização do Processador:** Nível de capacidade recomendado (média de 90%). **Throughput:** Quantidade de processos executados dentro de um intervalo de tempo (diretamente proporcional). **Tempo de Processador/UCP:** Tempo para um processo ser executado e finalizado. **Tempo de Espera:** Tempo que um processo fica na fila dos processos em estado de pronto. **Tempo de Turnaround:** Tempo total desde a criação até o encerramento de um processo. **Tempo de Resposta:** Tempo desde a criação do processo para ser atendido pelo sistema (depende da velocidade dos dispositivos de E/S, principalmente em aplicações web). | | Avaliar e selecionar o algoritmo adequado às necessidades de processamento e funcionalidades. | | | A avaliação analítica pode ser por modelagem determinística, por enfileiramento, simulações ou implementação em testes. | |
| | Objetivos do Escalonador | Metas que o escalonador de processos busca atingir para otimizar o uso da CPU e a experiência do usuário. | | | | Dar privilégios para aplicações críticas. Balancear o uso da CPU entre processos. Ser justo com todos os processos, permitindo que todos usem o processador. Maximizar a produtividade (throughput). Proporcionar menores tempos de resposta para usuários interativos. | | | | |
| | Tipos de Escalonamento | Diferentes abordagens para gerenciar a execução de processos e alocar recursos da CPU. | | **Não Preemptivo:** Recursos dedicados; liberação da CPU apenas quando o processo é finalizado ou por erro de execução. **Preemptivo:** Compartilhamento de tempo e recursos; intercala os processos em execução. | **Algoritmos Não Preemptivos:** FIFO (First In First Out), FCFS (First Come First Served), SJF (Shortest Job First), HRRN (Highest Response Ratio Next). **Algoritmos Preemptivos:** RR (Round Robin). | | | | | |
| | Critérios de Comportamento de Processos | Características que descrevem como um processo utiliza o processador e interage com o sistema. | | **Orientado a Processador:** Processo tende a utilizar todos os recursos do processador atribuído. **Operações de E/S:** Utiliza o processador apenas para requisições de E/S, depois libera. **Processo em Lote:** Alocação de recursos de processamento sem interação com o usuário. **Processo Interativo:** Usuário participa com entradas de dados; tempos de resposta precisam ser mais rápidos. | | | | | | |
| **Sistemas de Arquivos (S.A.) - Geral** | Introdução e Definição | Os sistemas de arquivos servem para facilitar a organização de arquivos sob o ponto de vista do armazenamento e de sua identificação. | Todos os componentes do S.O. se relacionam. A organização dos dados é de extrema importância para o direcionamento no sistema. A extensão dos arquivos determina um procedimento distinto de armazenamento e alocação de recursos. | | | Facilitar a organização e identificação de arquivos. Realizar operações como criar, excluir/remover, abrir, ler, gravar, fechar, identificar/reconhecer, obter e modificar arquivos com metadados. Gerenciar o caminho do dispositivo ou local de armazenamento do arquivo. | Falhas de energia podem levar à perda de dados sem uma política de backup estabelecida. | Procedimento de recuperação de dados e softwares auxiliares para minimizar perdas. | O S.O. trata as informações de arquivos isoladamente através do S.A., independente do tipo de mídia ou dispositivo de armazenamento. | |
| | Atribuição de Nomes | Regras e padrões estabelecidos pelo sistema de arquivos para nomear arquivos. | O nome do arquivo será limitado ao padrão e regras do S.A.. É uma sequência de caracteres (letras maiúsculas/minúsculas, números). Pode obedecer a restrições de extensão e tipos de caracteres válidos. | Espaço de nomes (disponibilização de possíveis nomes). Espaço de nomes hierárquico (estrutura em árvore). | | Converter os nomes em locais onde o arquivo está armazenado. Identificar um arquivo. | | | Nomes podem solicitar drivers de dispositivos, comunicação ou interface com outros processos. Podem fazer referência a dados existentes, gerados durante o processamento ou a nenhum dado. | |
| | Atributos de Arquivos | Informações que descrevem um arquivo e suas características. | | Tamanho (quantidade de caracteres ou bytes). Proteção (padrões de segurança de acesso). Dono/Proprietário/Usuário (quem criou, conta associada). Criação (data e hora de criação, facilita busca). Backup (data e hora da última atualização). Organização (lógica e hierarquia utilizada para armazenamento). | | Facilitar a busca pelo arquivo. Estabelecer quem criou e associa ao usuário ou conta. | | | | |
| | Operações do S.A. | Funções básicas que o sistema de arquivos pode desempenhar. | Quando um arquivo precisa ser aberto, criado, fechado, etc., o S.O. compreende a operação como um processo a ser executado. Direciona o driver correto para que a ação aconteça. | Criar, excluir/remover, abrir, ler, gravar, fechar, identificar/reconhecer, obter e modificar arquivos com metadados. | | Gerenciar arquivos e seu acesso. | | Precisam-se configurar as permissões necessárias para a execução de cada ação. | O sistema de arquivos determina como os arquivos são armazenados e identificados, independente do tipo de mídia. | |
| **Organização e Estrutura de Arquivos** | Tipos de Organização | Métodos de organização dos dados dentro de um arquivo. | | **Sequencial (não estruturada):** Não há uma estrutura lógica definida. Acesso precário (requer leitura de todos os registros até encontrar o procurado). Organização física baseada na limitação de bytes/blocos da aplicação. **Indexada:** Dados se interligam através de um índice, organizando registros de acordo com uma regra (ex: idade, altura, sexo, classe social). Requer um dado em comum (chave de acesso). **Relativa ou Direta:** Alocação dinâmica e aleatória do arquivo. Pode ser localizado a partir de uma chave de acesso e do local de armazenamento. | | Otimizar a localização e acesso aos arquivos. | | | | |
| **Sistemas de Diretórios** | Estrutura de Diretórios | Como o sistema organiza logicamente os diversos arquivos contidos em um disco. | Estrutura de dados que contém entradas associadas aos arquivos (com localização física, nome, organização e atributos). | Nível Único, Dois Níveis, Estrutura em Árvore. | | O S.O. procura a entrada na estrutura de diretórios ao abrir um arquivo, armazenando as informações na memória principal para aumentar o desempenho. | | | É importante que os arquivos sejam fechados ao término do uso para liberar espaço na tabela de arquivos abertos. | |
| | Diretório de Nível Único | Estrutura de diretório onde todos os arquivos de todos os usuários residem em um único diretório. | | | | | Usuários não podem criar arquivos com o mesmo nome para evitar conflitos de acesso. | | Possui muitas limitações. | |
| | Diretório de Dois Níveis | Estrutura de diretório que resolve os conflitos de nomes do nível único. | O primeiro nível destina-se à divisão de contas de usuários, e o outro à alocação dos arquivos criados. O diretório do usuário aponta para sua respectiva área de alocação de arquivos. | | | Permite que arquivos criados por contas de usuários distintos tenham os mesmos nomes, pois não estão alocados no mesmo diretório. | | | | |
| | Estrutura em Árvore | Organização hierárquica de diretórios. | A raiz é a própria área do usuário, os galhos são os diretórios e as folhas são os arquivos. Permite que o usuário crie diversos níveis de diretórios, cada um podendo ter outros diretórios ou vários arquivos. A quantidade de níveis pode variar de acordo com o S.O.. | | O caminho para um arquivo é chamado de "path". **Ex. Linux:** / (root), /bin (arquivos executáveis), /etc (arquivos de configuração), /home (diretório do usuário), /usr (arquivos compartilháveis). | Facilita a organização dos arquivos para o usuário. | | | | |
| | Alocação de Arquivos | Gerência dos espaços disponíveis em disco para armazenar arquivos. | O S.O. precisa saber quanto e quais partes do HD estão disponíveis. | **Tabelas:** Cada linha da tabela representa um bloco do HD (0=livre, 1=ocupado). Desvantagem: ocupa muito espaço em memória. **Listas Encadeadas:** O controle ocorre através dos blocos de disco livres. Cada bloco contém uma área que determina o endereço do próximo bloco. | | Gerenciar o espaço em disco para alocação de arquivos. | Alto consumo de memória com a estrutura de tabelas. | | | |
| **Implementação de Sistemas de Arquivos** | Descritor de Arquivos | Um registro no qual são mantidas as informações a respeito do arquivo. | Inclui seus atributos e outros dados necessários para que o S.O. implemente as operações sobre arquivos, mas não visíveis aos usuários. É acessado em todas as operações de leitura e escrita do arquivo. | | | Manter as informações do arquivo. Permitir que o S.O. implemente operações. | | O sistema de arquivos mantém uma tabela com todos os descritores dos arquivos em uso na memória para acesso rápido. O S.O. salva uma cópia que sobrepõe a anterior se o descritor for alterado. As chamadas de sistema open/close verificam se o arquivo foi alterado e seu estado (em uso/não mais) com parâmetros READONLY e READWRITE. | | |
| | Tabelas de Descritores | Estruturas de dados para gerenciar arquivos abertos e seus descritores. | | **TDAA (Tabela de Descritores de Arquivos Abertos):** Mantém atualizadas as informações dos arquivos abertos para todos os processos. **TAAP (Tabela de Arquivos Abertos por Processo):** Criada para cada arquivo aberto, contém a posição corrente do arquivo, tipo de permissão e ponteiro para TDAA. | | Reparar possíveis conflitos de acessos quando um arquivo é acessado por vários processos ao mesmo tempo. | | | | |
| | Métodos de Alocação | Estratégias para armazenar arquivos no disco e gerenciar o espaço. | | **Alocação Contígua**. **Alocação por Lista Encadeada:** Arquivos organizados como um conjunto de blocos logicamente ligados no disco, independente da localização física. Cada bloco contém um ponteiro para o bloco seguinte. **Alocação por Lista Encadeada usando uma tabela na memória (FAT - File Allocation Table):** Cada palavra de ponteiro de cada bloco de disco é inserida em uma tabela na memória principal. **I-nodes (index-node):** Cada arquivo é associado a uma estrutura I-node, relacionando atributos e endereços em disco dos blocos de arquivos. Permite encontrar todos os blocos. | | Otimizar o acesso e o armazenamento dos arquivos. | | | | |
| | NFS (Network File System) | Um sistema de arquivos de rede. | Compatível com sistemas operacionais Windows, Unix e Linux. Oferece maior segurança usando o protocolo RPSEC_GSS. Integrado à gestão de máquinas cliente e servidores. Suporta aplicações de servidores clusterizados e redes geograficamente distribuídas. Interage e integra serviços com o Active Directory. | | | Melhorar a acessibilidade e a segurança. | | **Procedimento de Instalação (Windows Server 2012+):** Instalar os serviços "Servidor NFS" e "Cliente NFS" via Gerenciador do Servidor (Adicionar funções e recursos -> Arquivo e serviços de armazenamento -> Servidor de arquivos e servidor de NFS) ou Windows PowerShell (`Import-module ServerManager`, `Add-WindowsFeature FSNFS-Services`, `Import-module NFS`). | Recomendado para ambientes com sistemas operacionais mistos (Windows, Unix, Linux). | |
| **Segurança do Sistema de Arquivos** | Mecanismos de Proteção | Formas pelas quais o S.O. protege os arquivos compartilhados para que usuários e processos sem permissão não consigam acessá-los. | O S.O. deve oferecer proteção. Visam manter a integridade dos arquivos. | Senha de acesso (requer conhecimento para acesso). Grupo de usuários (associa usuário a um grupo para compartilhamento). Lista de Controle de Acesso (ACL) (lista associada a cada arquivo com permissões por usuário). | | Proteger arquivos contra acessos indevidos. Garantir a integridade dos arquivos. | | Cópias de segurança (backups) garantem que os dados sejam copiados e armazenados em diferentes lugares e dispositivos. Consistência do sistema de arquivos permite que arquivos sejam salvos antes de finalizar a tarefa. | | |
| | Firewall | Uma interface de software ou hardware que filtra o tráfego de rede. | Tem a função de delimitar o que é permitido trafegar pela porta de entrada de rede da empresa. Configura regras de segurança. | | **Ex.: Gufw (Graphical Firewall Uncomplicated)** para Linux. | Proteger a rede da empresa, controlando o tráfego de dados. | A empresa utiliza diversos S.O. e serviços de software, exigindo muitas regras de segurança que privilegiem ambos os ambientes. | **Procedimento de Instalação e Configuração (Gufw para Linux):** Download do Gufw (http://gufw.org/), seguir passos do fornecedor e utilizar o Synaptic. | O software é voltado para sistemas operacionais Linux, mas pode ser usado em ambientes que também têm Windows. | |
| **Gerenciamento de Memória** | Conceitos Gerais | Tarefa do S.O. para gerenciar o uso da memória. | O S.O. deve proteger as áreas de memória utilizadas pelos processos. Controlado pelo gerenciador de memória. | | | Gerenciar quais partes da memória estão em uso e quais não estão. Alocar memória quando os processos precisarem e liberá-la após o término. Controlar a troca de processos entre memória e disco quando a memória principal não é suficiente. Manter a maior quantidade de processos residentes na memória física para maximizar o compartilhamento de recursos. | A quantidade de memória suficiente em dispositivos móveis é um desafio (armazenar S.O., apps, registros, espaço para usuário). | **Ferramentas de otimização para dispositivos móveis:** Limpar cache (Cache Cleaner), mover apps para cartão de memória (Link2SD), backup de dados, desinstalar arquivos ocultos (Easy Uninstaller), salvar arquivos em cartão externo. | A MMU (Memory Management Unit) mapeia endereços lógicos (gerados pelo processo) para endereços físicos (na memória principal). | |
| | Alocação de Memória | Processo de divisão da memória em partes (particionamento) para alocar os programas. | | **Alocação Contígua Simples:** Memória principal dividida em duas áreas (S.O. e aplicações do usuário). Mais voltada para S.O. monoprogramáveis. **Técnica de Overlay:** Divisão da aplicação em módulos para alocar de acordo com os espaços que cada um ocupará, executando um módulo por vez. **Alocação Particionada:** Permite maior aproveitamento dos espaços de memória principal. | | | **Contígua Simples:** Aplicações de usuários tinham que respeitar limitações da área de alocação predeterminada. **Particionada Estática/Fixa:** Partiçõess tinham tamanho fixo, necessitando reconfigurar sistemas ao redimensionar. | **Alocação Particionada:** Estática/Fixa (partições de tamanho fixo, definidas por necessidades). Dinâmica (não há necessidade de definir tamanho das partições, o programa recebe apenas o espaço suficiente). | | |
| | Multiprogramação com Partições Fixas | Capacidade da maioria dos S.O. modernos de permitir que vários processos executem ao mesmo tempo. | Quando um processo é bloqueado aguardando uma informação de E/S, outro processo pode utilizar a CPU, aumentando sua utilização. | | | Aumentar a utilização da CPU. | **Problemas:** **Relocação** (transferência de código sem que um programa escreva na área de outro, necessária pois processos executam em diferentes endereços na memória física). **Proteção** (garantir que um programa não acesse indevidamente a área de memória de outro). | Solução para relocação e proteção: o processador recebe dois registradores (base e limite). | **Monoprogramação sem troca de processos ou paginação:** Método mais simples, apenas um programa por vez, memória compartilhada entre S.O. e programa. Modelos: S.O. usando RAM, S.O. usando ROM (embarcados), drivers em ROM e S.O./programas em RAM (MS-DOS). | |
| **Swapping (Troca de Processos)** | Conceito e Funcionamento | Técnica realizada quando não existe memória principal suficiente para executar todos os programas do computador simultaneamente. | Um programa é totalmente carregado na memória, executado por um tempo definido, e depois retorna para o disco enquanto outros programas aguardam sua vez. | | **Swap out:** Processo residente é transferido da memória principal para a memória secundária (disco). **Swap in:** Processo é carregado de volta da memória secundária para a principal. **Outswapped:** Processo em estado de espera ou pronto, considerado não residente. | Compartilhar mais recursos ou endereços na memória principal. Otimizar o processamento e maximizar a utilização geral da máquina. | Custo de processador com as operações de E/S (swap out e swap in) pode levar à perda de eficiência, pois recursos podem estar dedicados ao swapping. | Requer o uso de um registrador de alocação: acionado ao carregar o programa, recebe o endereço inicial e gera o endereço físico somando novas solicitações. | | |
| | Tipos de Swapping | Diferentes estratégias e políticas associadas à técnica de swapping. | | Swapping por paginação ou paginação de swapping. Strings de referência (lista de acessos a página). Políticas de substituição global (Mínimo de Belady, Segunda Chance, Algoritmo do Relógio, Conjunto de Trabalho, Frequência de Falha, Segmentos Paginados, Arquivos Mapeados na Memória). | | | | | | |
| | Algoritmos de Troca de Processos | Estratégias para definir em qual área livre os processos serão executados na memória. | Reduzem ou evitam a fragmentação externa. | **First Fit (primeiro que couber):** Mais simples, consome menos recurso, procura o primeiro segmento livre suficientemente grande. **Next Fit (próximo que couber):** Variação do First Fit, memoriza a última posição encontrada, não percorre toda a lista. **Best Fit (melhor que couber):** Percorre toda a lista e escolhe o menor segmento livre suficiente. Mais lento. **Worst Fit (pior que couber):** Escolhe o maior segmento disponível para que o restante seja útil. Não é uma boa ideia. **Quick Fit (mais rápido que couber):** Rápido, mantém listas separadas por tamanhos de segmentos mais solicitados. | | Otimizar a alocação de memória e reduzir a fragmentação. | | | | |
| | SWAP no Windows e Linux | Implementação e características da memória de troca em diferentes sistemas operacionais. | | **Windows:** Arquivo PAGEFILE.SYS dentro do diretório raiz (C:/). Tamanho varia com a quantidade de memória RAM (ex: 2GB RAM -> 2048MB). Pode ser alterado ou desativado. **Linux:** É uma partição no diretório raiz (/). Pode ser utilizada por vários sistemas operacionais. | | | | **Configuração SWAP no Linux (Debian 7.0 Wheezy):** 1. Verificar instalação (`swapon -s`, `free -m`). 2. Verificar espaço livre no HD (`df -h`). 3. Criar partição Swap (`fallocate -l 2G /swapfile`). 4. Verificar criação (`ls -lh /swapfile`). 5. Definir permissões e habilitar (`chmod 600 /swapfile`, `mkswap /swapfile`, `swapon /swapfile`). 6. Tornar permanente (editar `/etc/fstab`). 7. Evitar erros (`mount -a`). 8. Verificar uso (`watch -n 5 free -m`). | | |
| **Memória Virtual** | Conceitos e Funcionamento | Permite que o volume de informações de um programa (código, dados, pilha) ultrapasse a quantidade total de memória física disponível. | Mantém as partes ativas do programa na memória principal e as demais no disco rígido. É um arquivo dinâmico e de tamanho variável na maioria dos S.O.. Permite que vários processos compartilhem a memória principal, utilizando apenas as partes ativas dos processos, o que reduz a fragmentação e otimiza o processador. | | Instruções de código são desenvolvidas para trazer a instrução de acordo com sua identificação. Aplicativo/software não referencia diretamente endereços físicos, mas sim endereços virtuais, que são convertidos para físicos (mapeamento). | Aumentar o espaço disponível de memória. Proporcionar uma utilização eficiente do processador. | | Um algoritmo de mapeamento, inserido na decodificação do endereço virtual para físico, permite não alocar processos contiguamente na memória principal. A unidade de gerência de memória é responsável por essa conversão. Interage com a técnica de swapping. | | |
| | Técnicas de Implementação | Métodos pelos quais a memória virtual é implementada. | | Paginação. Segmentação. Segmentação com Paginação. | | | | | | |
| | Paginação | Uma técnica de gerência de memória em que o endereçamento virtual e o espaço de endereçamento real são divididos em blocos do mesmo tamanho, chamados páginas. | | | | Fornecer um espaço de endereçamento linear sem a necessidade de adquirir mais memória física. | | | | |
| | Políticas de Gerenciamento de Páginas | Estratégias para como o S.O. gerencia a demanda de processos no contexto da alocação de recursos em memória virtual. | | **Políticas de busca de páginas:** Paginação por demanda (transferência para a memória principal apenas quando há referência). Paginação antecipada (acréscimo de páginas caso o processo venha a precisar). **Políticas de:** Alocação de páginas, Substituição de páginas (Ótimo, Aleatória, FIFO, LFU, LRU, NRU, FIFO com buffer, FIFO circular), Working Set, Tamanho da página, Paginação com múltiplos níveis, Tradução de endereços virtuais em reais, Proteção de memória, Compartilhamento de memória. | | Otimizar a alocação e o desempenho da memória virtual. | | | | |
| | Configuração no Windows | Procedimento para aumentar o tamanho da memória virtual em sistemas Windows. | | | | Aumentar o tamanho mínimo do arquivo de paginação se houver avisos de memória virtual insuficiente. | | **Passos:** 1. Abrir Sistema (Iniciar > Computador > Propriedades). 2. Configurações avançadas do sistema. 3. Na guia Avançado, em Desempenho, clique em Configurações. 4. Na guia Avançado, em Memória virtual, clique em Alterar. 5. Desmarcar "Gerenciar automaticamente". 6. Selecionar unidade. 7. Clicar em "Personalizar Tamanho" e digitar novo tamanho (MB) em "Tamanho inicial" e "Tamanho máximo". 8. Clicar em Definir e OK. | O Windows define o tamanho inicial como a RAM instalada e o tamanho máximo como três vezes a RAM instalada. | |
| **Gerenciamento de Dispositivos de E/S** | Conceitos e Funções | Uma das tarefas mais complexas que o sistema operacional realiza. | É responsável por facilitar a comunicação entre as solicitações dos usuários e as aplicações. A arquitetura de comunicação entre os dispositivos de E/S e os respectivos hardwares e softwares precisa estar interligada para atender às demandas. | | Subsistema de E/S, Device Driver, Controlador, Dispositivos de E/S, Discos Magnéticos/SGBD, Segurança. | Facilitar a comunicação e atender às demandas de E/S. | | | A arquitetura de gerência de dispositivos é dividida em camadas. | |
| | Camadas da Gerência de E/S | Estrutura hierárquica que distribui as responsabilidades na gerência de dispositivos. | | **1. Dispositivos ou Periféricos de E/S:** Mecanismos que permitem a interação entre usuário e máquina. **2. Controlador:** Hardware que faz a interface entre a solicitação do usuário e o driver. Composto por memória e registradores programados para enviar instruções ao driver. **3. Device Driver:** Camada de instruções que realiza a comunicação das solicitações enviadas pelo controlador ao subsistema de E/S. **4. Subsistema de E/S:** Distingue as solicitações de acordo com cada dispositivo e executa rotinas de comunicação entre aplicações, S.A. e SGBDs. **5. Sistema de Arquivos, SGBDs, Aplicações:** Relacionam-se para gerar as demandas de processos. | | **Controlador:** Armazena sequências de bits do dispositivo de E/S; envia bloco para memória principal sem erros. **Device Driver:** Interpreta/traduz instruções recebidas para comandos compreensíveis. **Subsistema de E/S:** Isolar atividades e solicitações dos periféricos, aplicações, S.A. e SGBDs para que periféricos interajam de forma diferente. | | Observa-se o isolamento no tratamento de informações de dispositivos para com as informações do processo. | A camada de subsistema de E/S lida com a diversidade de dispositivos, isolando suas atividades. | |
| | Rotinas de E/S | Conjunto de rotinas que geram as demandas de execução das operações de E/S. | Podem estar organizadas logicamente ou de forma estruturada (em dispositivos como pen drives, HD) ou não estruturada (quando o dispositivo não permite essa configuração). | | | Otimizar a comunicação. | | | | |
| | Formas de Comunicação de E/S | Métodos para estabelecer a comunicação de entrada e saída. | | **Chamada Explícita:** Caracteriza-se pela chamada realizada diretamente pelo S.O. a partir de comandos de alto nível. **Chamada Implícita:** Realização das operações de E/S para leitura e gravação através de programação de alto nível (Ex: linguagem C). | | | | | | |
| | Line Discipline | Uma interface entre os processos de usuários e os drivers de terminal. | Responsável por realizar a codificação e decodificação das solicitações de usuários em informações ou instruções de máquina. | **Raw:** Responsável pela transmissão dos caracteres de entrada. **Cooked:** Responsável pela codificação dos caracteres de entrada. | | | | A informação deve passar pelo interpretador de comandos (shell). | | |
| | Clist (Lista de Caracteres) | Uma lista encadeada de blocos de caracteres (Cblocks). | Armazena um vetor do tipo caractere com as informações enviadas pelos dispositivos de E/S. Aponta para o próximo bloco de endereços, considerando o tamanho do vetor (início e fim). Funciona como um tipo de buffer. | **Raw Clist:** Armazena os dados de entrada. **Cooked Clist:** Armazena os dados de entrada processados pelos modos de operação do line discipline. **Output Clist:** Armazena os dados de saída que deverão ser exibidos para o usuário. | | Realiza efetivamente três operações de leitura e escrita. | | | | |
