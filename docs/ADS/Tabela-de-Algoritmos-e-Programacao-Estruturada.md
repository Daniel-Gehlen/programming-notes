### Tabela de Conceitos de Algoritmos e Programação Estruturada

| Módulo / Teleaula | Conceito Principal | Sub-Conceito / Tópico Específico | Definição / Descrição Detalhada | Características / Propriedades Chave | Vantagens / Desvantagens (se aplicável) | Sintaxe / Exemplo (Código, Pseudocódigo) | Palavras-chave / Termos Relacionados | Uso / Finalidade Principal | Referências [Nº] |
|---|---|---|---|---|---|---|---|---|---|
| 01 / TA01 | **Algoritmos** | Definição | Uma **sequência ordenada de passos** que deve ser seguida para a realização de uma tarefa. | Passos finitos; Sem redundância; Sem subjetividade; Deve ser claro e objetivo. | - | Entrada -> Processamento -> Saída | Fundamentos, Programação, Tarefa | Base para a resolução de problemas computacionais. | |
| 01 / TA01 | **Algoritmos** | Formas de Representação | Diferentes métodos para expressar a lógica de um algoritmo. | **Descrição Narrativa**; **Fluxograma**; **Pseudocódigo**. | - | - | Representação, Lógica | Facilitar o entendimento e o projeto de algoritmos. | |
| 01 / TA01 | **Descrição Narrativa** | Definição | Utiliza a **linguagem natural** para descrever os passos de um algoritmo. | - | **Vantagem**: Uso da linguagem natural. **Desvantagem**: Imprecisão, subjetividade. | Exemplo: Receita do bolo (1. Misturar todos os ingredientes; 2. Untar a forma; etc.) | Linguagem natural, Passos | Descrição simples e informal de algoritmos. | |
| 01 / TA01 | **Fluxograma** | Definição | Uma **representação gráfica** de um algoritmo. | Cada forma geométrica define uma função genérica; As formas geométricas são ligadas por flechas que indicam o **fluxo da execução**. | - | Exemplo: Diagrama para cálculo de média (Início, Nota 1, Nota 2, Cálculo Média, Condição Média >=7, Aprovado/Reprovado, Fim). | Representação gráfica, Símbolos, Fluxo | Visualizar a lógica e o fluxo de controle de um algoritmo. | |
| 01 / TA01 | **Pseudocódigo** | Definição | Uma forma de representação de algoritmos que **assemelha-se à forma em que os programas são escritos**. | **Português estruturado**; A intenção é chegar na resolução do problema. | - | Exemplo: `algoritmo “Calcula Media” var nota1, nota2, media: real inicio escreva(“Digite a primeira nota:”) leia(nota1) media<-(nota1+nota2)/2 escreva(“Sua média é”, media) fim algoritmo` | Português estruturado, Resolução de problema | Projetar e testar a lógica de um algoritmo antes da implementação em uma linguagem de programação. | |
| 01 / TA01 | **Variáveis** | Definição | Um local que armazena um **conteúdo específico na memória principal do computador**. | Possuem **identificação única**; Nomes significativos; Caracteres válidos: números, letras (maiúsculas ou minúsculas), underline (_); Caracteres inválidos: “branco”, caracteres especiais (@, $, *, +, -, !, etc); O primeiro caractere de uma variável deve ser uma letra; Não pode usar palavras reservadas. | - | Exemplo: `Nome` (conteúdo: Vanessa), `Idade` (conteúdo: 18), `Telefone` (conteúdo: 9999-9999). | Memória, Conteúdo, Identificador | Armazenar e manipular dados durante a execução de um programa. | |
| 01 / TA01 | **Tipos de Dados** | Definição | Especifica as **características, valores e operações possíveis** de serem utilizadas com um dado. | - | - | - | Inteiro, Real, Caractere, Lógico | Definir o tipo de informação que uma variável pode conter e as operações permitidas. | |
| 01 / TA01 | **Tipos de Dados** | Inteiro | Representa valores inteiros. | - | - | Exemplo: 18; 300; -100. Em C: `int`. | `int`, Números inteiros | Armazenar números sem casas decimais. | |
| 01 / TA01 | **Tipos de Dados** | Real | Representa valores reais (decimais). | - | - | Exemplo: 5.5; 899.3; -22.22. Em C: `float`. | `float`, Números decimais | Armazenar números com casas decimais. | |
| 01 / TA01 | **Tipos de Dados** | Caractere | Representa uma **sequência de um ou mais caracteres**. | - | - | Exemplo: "Leo"; "A". Em C: `char`. | `char`, String, Texto | Armazenar letras, palavras, frases. | |
| 01 / TA01 | **Tipos de Dados** | Lógico | Representa **valores lógicos**. | - | - | Exemplo: Verdadeiro, Falso. | Booleano, Verdadeiro, Falso | Representar estados binários (sim/não, ligado/desligado). | |
| 01 / TA01 | **Linguagem C** | Estrutura Básica | A sequência lógica e os elementos fundamentais de um programa em C. | 1. Início do programa; 2. Definição das variáveis; 3. Instrução de leitura dos dados; 4. Instrução do formato de escrita; 5. Demais instruções e funções; 6. Fim do programa. | - | - | Fundamentos, Sintaxe C | Construir programas na linguagem C de forma organizada. | |
| 01 / TA01 | **Linguagem C** | Bibliotecas | Conjunto de **funções pré-definidas** que podem ser incluídas no programa para adicionar funcionalidades. | As primeiras linhas de programação são definidas pelas bibliotecas. | - | `#include <stdio.h>` | `stdio`, `stdlib`, `string`, `math` | Fornecer funcionalidades comuns como entrada/saída, manipulação de strings, operações matemáticas. | |
| 01 / TA01 | **Linguagem C** | Função `main()` | É o **início da execução de um programa em C**. | É a função principal de todo programa em C. | - | `void main() { ... }` | Ponto de entrada, Execução | Marcar o ponto de partida do programa. | |
| 01 / TA01 | **Linguagem C** | Declaração de Variáveis | Processo de informar ao compilador o **nome e o tipo de dado** que uma variável irá armazenar. | - | - | `int valor1, valor2, soma;` (Inteiro); `float media;` (Real); `char inicial;` (Caractere). | `int`, `float`, `char`, Tipagem | Alocar espaço na memória e definir as propriedades das variáveis. | |
| 01 / TA01 | **Operadores** | Atribuição | Atribui um **valor a uma variável**. | O valor pode ser uma expressão. | - | Símbolo: `=`. Exemplo: `a = 2; a = b + c;` | `=` | Armazenar resultados de expressões ou valores literais em variáveis. | |
| 01 / TA01 | **Operadores** | Aritméticos | Realizam **operações matemáticas**. | - | - | `+` (Adição): `y+x; 2+9;` `-` (Subtração): `nota-extra; v-n;` `*` (Multiplicação): `7*8; a*b; n*4;` `/` (Divisão): `n1/n2; media/2;` `%` (Resto da divisão): `15 % 2`. | Adição, Subtração, Multiplicação, Divisão, Módulo | Efetuar cálculos numéricos. | |
| 01 / TA01 | **Operadores** | Relacionais | Realizam **comparações entre valores**, retornando um valor lógico (verdadeiro/falso). | - | - | (Tabela de operadores relacionais implícita nas fontes, mas não detalhada: ==, !=, <, >, <=, >=) | Comparação, Lógico, Verdadeiro, Falso | Construir condições para estruturas de decisão e repetição. | |
| 01 / TA01 | **Operadores** | Lógicos | Utilizados para **combinar ou negar expressões lógicas**, retornando um valor lógico. | - | - | (Tabela de operadores lógicos implícita nas fontes, mas não detalhada: && (AND), || (OR), ! (NOT)) | Booleano, AND, OR, NOT | Criar condições complexas. | |
| 01 / TA01 | **Comando de Saída de Dados** | `printf()` | As informações, mensagens e conteúdo de variáveis são **enviadas para o usuário visualizá-las** (geralmente na tela). | - | - | Sintaxe: `printf (“expressão de controle”, listas de argumentos);`. Exemplo: `printf (“O valor encontrado foi %d”, valor1);`. | Saída, Exibir, Imprimir, Tela | Apresentar resultados, mensagens e informações ao usuário. | |
| 01 / TA01 | **Comando de Entrada de Dados** | `scanf()` | As informações digitadas pelos usuários são **transferidas para variáveis do programa**. | - | - | Sintaxe: `scanf(“expressão de controle”, lista de argumentos);`. Exemplo: `scanf (“%d”, &valor);`. | Entrada, Ler, Teclado | Receber dados inseridos pelo usuário para que o programa possa processá-los. | |
| 02 / TA02 | **Estruturas de Decisão** | `if` | Permite **tomar uma decisão e criar um desvio** dentro do programa, executando um bloco de comandos se uma condição for verdadeira. | - | - | `if (condição) { Comandos; }` | Condicional, Desvio, Verdadeiro | Executar um conjunto de instruções somente se uma condição específica for atendida. | |
| 02 / TA02 | **Estruturas de Decisão** | `if-else` | Executa um bloco de comandos se a condição for verdadeira e um **bloco alternativo** se a condição for falsa. | - | - | `if (condição) { comandos; } else { comandos; }` | Condicional, Alternativa, Falso | Executar um de dois blocos de código mutuamente exclusivos, com base em uma condição. | |
| 02 / TA02 | **Estruturas de Decisão** | `switch-case` | Estrutura de **seleção múltipla**, que executa diferentes blocos de código com base no valor de uma variável. | - | - | `switch (variável) { case constante1: <comandos> break; case constante2: <comandos> break; default: <comandos> }` | Seleção múltipla, Casos, `break`, `default` | Simplificar a lógica de decisão quando há muitas opções baseadas em um único valor. | |
| 02 / TA02 | **Estruturas de Decisão** | Encadeada | Combinação de **múltiplas estruturas condicionais**, como `if` e `else if`. | - | - | Implícito: `if (condição1) { ... } else if (condição2) { ... } else { ... }` | Aninhamento, Múltiplas condições | Gerenciar cenários com múltiplas condições e desvios complexos. | |
| 02 / TA02 | **Estruturas de Repetição** | `while` | Comandos serão **repetidamente executados enquanto uma condição verdadeira for verificada**, somente após a sua negativa essa condição será interrompida. | O teste da condição é feito **antes** de cada iteração (pré-teste). | - | `while (condição) { Comandos; }` | Loop, Repetição Condicional, Pré-teste | Executar um bloco de código um número indefinido de vezes, enquanto uma condição permanecer verdadeira. | |
| 02 / TA02 | **Estruturas de Repetição** | `do-while` | Analisa a condição ao **final do laço**, ou seja, os comandos são executados **antes do teste de condição** (garante pelo menos uma execução). | O teste da condição é feito **depois** de cada iteração (pós-teste). | **Vantagem**: Garante que o bloco de comandos seja executado pelo menos uma vez. | `do { comandos; } while (condição);` | Loop, Repetição Condicional, Pós-teste | Executar um bloco de código pelo menos uma vez, e continuar a repetição enquanto uma condição for verdadeira. | |
| 02 / TA02 | **Estruturas de Repetição** | `for` | Utilizado para **repetir uma informação ou bloco de comandos por um número fixo de vezes**. | É uma estrutura de repetição **determinística**, ideal para quando o número de iterações é conhecido. | - | `for (inicialização; condição final; incremento) { comandos; }` | Loop Determinístico, Contador | Executar um bloco de código um número predefinido de vezes. | |
| 02 / TA02 | **Loop (Elementos)** | Contador | Uma variável utilizada para **controlar o número de repetições** em um laço. | Pode ser incrementado ou decrementado. | - | Exemplo: `i = 0; i++; i--;` | Incremento, Decremento, Iteração | Rastrear o progresso das repetições e determinar o fim do loop. | |
| 02 / TA02 | **Loop (Elementos)** | Acumulador | Uma variável que **irá somar as entradas de dados de cada iteração** da repetição, gerando um somatório. | - | - | Exemplo: `soma = soma + valor_atual;` | Somatório, Agregação | Acumular valores (somas, produtos, etc.) ao longo das iterações de um loop. | |
| 02 / TA02 | **Loop (Elementos)** | Condição de Parada | Um critério utilizado para **determinar o momento de parar** uma repetição, especialmente quando não se tem um valor exato do número de repetições. | Essencial para evitar loops infinitos. | - | Exemplo: `while (resposta != 'S');` | Fim do loop, Critério de saída | Controlar o término de loops condicionais. | |
| 02 / TA02 | **Vetores** | Definição | Um **tipo especial de variável** que armazena **diversos valores "ao mesmo tempo"**, usando um mesmo endereço na memória. | É uma **estrutura de dados linear** (arranjo unidimensional); Todos os elementos de um vetor são do **mesmo tipo**. | - | Sintaxe: `tipo variavel [n]`. Exemplo: `int notas;` | Array, Arranjo, Lista, Unidimensional | Armazenar e organizar coleções de dados homogêneos sob um único nome. | |
| 02 / TA02 | **Matrizes** | Definição | **Arranjos de duas ou mais dimensões**. | Assim como nos vetores, todos os elementos de uma matriz são do **mesmo tipo**, armazenando informações semanticamente semelhantes; O **índice começa por zero** (ex: (0,0) para a primeira posição); Não é obrigatório que todas as posições sejam ocupadas. | - | Sintaxe: `tipo variável [m][n]`. Exemplo: `float tabela;` | Arranjo Bidimensional, Tabela | Armazenar e organizar dados em formato de tabela (linhas e colunas). | |
| 02 / TA02 | **Variáveis Compostas** | Índice | A **posição de um elemento** dentro de um vetor ou matriz. | O índice **começa por zero** (0). | - | Exemplo: `vetor` (primeiro elemento do vetor); `matriz` (primeiro elemento da matriz). | Posição, Elemento | Acessar e manipular elementos individuais dentro de vetores e matrizes. | |
| 03 / TA03 | **Funções** | Definição | Um **trecho de código escrito para solucionar um subproblema**. A ideia de criar programas com blocos de funcionalidades vem de uma técnica de projeto de algoritmos chamada **dividir para conquistar**. | **Modularização** do código. | **Vantagens**: Dividir a complexidade de um problema maior; Evitar repetição de código. | Estrutura: `<tipo de retorno> <nome> (<parâmetros>) { Comandos; return <valor>; }` | Procedimentos, Modularização, Reutilização, Subproblema | Organizar programas em blocos lógicos, promover o reuso de código e simplificar a manutenção. | |
| 03 / TA03 | **Funções** | Elementos da Função | Componentes que definem a estrutura e o comportamento de uma função. | **`<tipo de retorno>`**: Obrigatório (pode ser `int`, `float`, `char`, `void`, etc.); **`<nome>`**: Obrigatório, identifica a função; **`<parâmetros>`**: Opcional, dados de entrada da função; **`<retorno>`**: Obrigatório quando o tipo de retorno não é `void`. | - | Exemplo: `int somar(int a, int b) { return a + b; }` | Assinatura da função, Protótipo | Definir corretamente a interface e o resultado esperado de uma função. | |
| 03 / TA03 | **Ponteiros** | Definição | Um **tipo especial de variável que armazena um endereço de memória**. | - | - | Criação: `int *idade;` Atribuição: `int ano = 2018; int *ponteiro_para_ano = &ano;` | Endereço de memória, Variável especial | Acesso direto e manipulação de memória, passagem por referência. | |
| 03 / TA03 | **Ponteiros** | Operadores | Símbolos utilizados para manipular e interagir com ponteiros e endereços de memória. | - | - | **Asterisco (`*`)**: Usado para criação do ponteiro e para acessar o valor no endereço apontado. **Ampersand (`&`)**: Usado para acessar o endereço de memória de uma variável. | `*`, `&`, Endereço, Valor | Criar ponteiros, obter endereços e acessar os valores armazenados nos endereços apontados. | |
| 03 / TA03 | **Funções com Ponteiros** | Aplicação | Uso de ponteiros em funções para manipular diretamente dados na memória ou retornar estruturas complexas. | É o correto para **retornar um vetor** (não `int calcular()`). | - | - | Retorno de vetor, Manipulação de memória | Permitir que funções operem diretamente em dados externos ou retornem estruturas de dados mais complexas. | |
| 03 / TA03 | **Função `malloc()`** | Definição | Uma função utilizada para **alocar memória dinamicamente** em tempo de execução. | Retorna dois valores possíveis: `NULL` (em caso de falha na alocação) ou um ponteiro genérico. | - | Exemplo: `int* memoria = malloc (100);` | Alocação dinâmica, Memória, `NULL` | Reservar blocos de memória de tamanho variável durante a execução do programa. | |
| 03 / TA03 | **Escopo** | Variável Local | Variáveis que são "**enxergadas**" somente dentro do corpo da função ou bloco de código onde foram definidas. | Existem apenas dentro do seu bloco de definição; São liberadas da memória após a execução do bloco. | - | - | Visibilidade, Bloco, Função | Garantir o encapsulamento de dados e evitar conflitos de nomes entre diferentes partes do programa. | |
| 03 / TA03 | **Escopo** | Variável Global | Variáveis criadas **fora de qualquer função**, sendo visíveis por todas as funções do programa. | Geralmente adota-se declará-las após as bibliotecas. | - | - | Visibilidade, Programa, Compartilhamento | Compartilhar dados entre múltiplas funções sem a necessidade de passá-los como parâmetros. | |
| 03 / TA03 | **Passagem de Parâmetros** | Por Valor | A função cria **variáveis locais automaticamente para armazenar cópias** dos valores passados como argumentos. | Após a execução da função, essas variáveis locais são liberadas; As alterações dentro da função não afetam as variáveis originais. | - | - | Cópia, Variáveis locais | Proteger os valores originais das variáveis do chamador de alterações indesejadas pela função. | |
| 03 / TA03 | **Passagem de Parâmetros** | Por Referência | Passa o **endereço da variável** (usando ponteiros) para a função, que trabalhará **diretamente com os valores ali armazenados**. | **Não será criada uma cópia** dos argumentos passados; Utiliza ponteiro e endereço de memória. | - | - | Endereço, Ponteiro, Sem cópia | Permitir que uma função modifique diretamente o valor de uma variável declarada fora dela. | |
| 03 / TA03 | **Recursividade** | Função Recursiva | Uma função que é **invocada dentro dela mesma** para resolver um problema. | Resolve um problema dividindo-o em subproblemas mais simples, cuja a solução é a aplicação dele mesmo; Necessita de um **ponto de parada** para evitar loops infinitos; As variáveis em cada invocação são independentes. | - | Exemplo: Fatorial, Fibonacci (`fibonacci(n-1) + fibonacci(n-2)`). | Auto-invocação, Ponto de Parada, Subproblemas | Solucionar problemas que podem ser naturalmente divididos em instâncias menores do mesmo problema. | |
| 03 / TA03 | **Recursividade** | Ponto de Parada | A **condição fundamental** em uma função recursiva que define **quando a recursão deve terminar**. | Essencial para evitar que a função entre em um loop infinito. | - | Exemplo: `if (n == 0) return 0;` na função Fibonacci. | Condição base, Fim da recursão | Assegurar que a recursão termine e retorne um valor final, evitando estouro de pilha. | |
| 03 / TA03 | **Exemplos de Recursividade** | Fatorial | O fatorial de um número qualquer N consiste em **multiplicações sucessivas até que N seja igual ao valor unitário (1)**. | - | - | `5! = 5 × 4 × 3 × 2 × 1 = 120`. | Multiplicação sucessiva, N! | Cálculo de fatoriais de números. | |
| 03 / TA03 | **Exemplos de Recursividade** | Fibonacci | Uma **sequência numérica** onde cada número é a soma dos dois anteriores, começando geralmente por 0 e 1. | - | - | Exemplo de função: `int fibonacci(int n) { if (n == 0) return 0; else { if (n == 1) return 1; else return fibonacci(n-1) + fibonacci(n-2); } }` | Sequência, Soma dos anteriores | Calcular o n-ésimo elemento da sequência de Fibonacci. | |
| 04 / TA04 | **Estrutura de Dados** | `Struct` | Uma **variável que armazena valores de tipos diferentes**, agrupando-os sob um único nome. | Permite agrupar dados heterogêneos relacionados. | - | Exemplo: `struct aluno { char nome; int idade; };` | Registro, Tipos diferentes, Dados compostos | Organizar e gerenciar dados que, embora de tipos diferentes, estão semanticamente relacionados. | |
| 04 / TA04 | **Listas** | Lista Ligada | Uma **estrutura de dados linear e dinâmica**. | Cada elemento da sequência é armazenado em uma **célula (nó)** da lista; Permite inserção e remoção de elementos de forma flexível. | - | - | Linear, Dinâmica, Célula, Nó | Armazenar e gerenciar coleções de dados onde a inserção e remoção são frequentes, sem a necessidade de realocação contígua. | |
| 04 / TA04 | **Lista Ligada** | Operações Básicas | As ações fundamentais que podem ser realizadas em uma lista ligada. | - | - | **Criação** ou definição da estrutura; **Inicialização** da lista; **Inserção** de elementos; **Remoção** de elementos; **Percorrer** a lista; **Verificar** se um elemento se encontra na lista. | Inserção, Remoção, Busca, Travessia | Gerenciar o ciclo de vida e o conteúdo de uma lista ligada. | |
| 04 / TA04 | **Lista Ligada (Operações)** | Inserção | Ação de **adicionar elementos** em uma lista ligada. | Para inserir, é necessário alocar o espaço na memória e **atualizar o valor do ponteiro**; Pode ocorrer no final, na primeira posição ou no meio da lista. | - | (Fluxograma de inserção na fonte, ilustra alocação e ajuste de ponteiros). | Alocação, Ponteiro, Adicionar | Adicionar novos dados à estrutura de forma eficiente. | |
| 04 / TA04 | **Lista Ligada (Operações)** | Remoção | Ação de **retirar um nó (elemento)** de uma lista ligada. | Requer o deslocamento do nó removido e a **atualização do valor do ponteiro**; Pode ocorrer no primeiro elemento ou no meio da lista. | - | (Fluxograma de remoção na fonte, ilustra ajuste de ponteiros). | Deslocamento, Ponteiro, Retirar | Remover dados da estrutura e liberar a memória associada. | |
| 04 / TA04 | **Pilha (`Stack`)** | Definição | Uma estrutura de dados do tipo **LIFO (Last-In First-Out)**. | O **último elemento a ser inserido, será o primeiro a ser retirado**. | - | - | LIFO, Last-In First-Out, `Stack` | Gerenciamento de chamadas de função, desfazer/refazer ações, validação de expressões. | |
| 04 / TA04 | **Pilha** | Operações | As duas operações básicas para manipular uma pilha. | - | - | **Empilhar (`push()`):** Adicionar um elemento à pilha. **Desempilhar (`pop()`):** Retirar um elemento da pilha. | `push`, `pop`, Empilhar, Desempilhar | Adicionar e remover elementos de acordo com a lógica LIFO. | |
| 04 / TA04 | **Fila (`Queue`)** | Definição | Uma estrutura de dados do tipo **FIFO (First-In First-Out)**. | O **primeiro elemento a ser inserido, será o primeiro a ser retirado**; Adiciona-se itens no fim e remove-se do início. | - | - | FIFO, First-In First-Out, `Queue` | Gerenciamento de tarefas em sistemas operacionais, buffer de impressão, simulações. | |
| 04 / TA04 | **Fila** | Operações | Os passos fundamentais para a criação e manipulação de uma fila. | - | - | **Criar** uma fila vazia; **Inserir** elemento no final; **Retirar** um elemento do início; **Verificar** se a fila está vazia. | Enfileirar, Desenfileirar, `isEmpty` | Adicionar e remover elementos de acordo com a lógica FIFO. | |
